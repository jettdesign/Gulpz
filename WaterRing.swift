//
//  WaterRing.swift
//  Gulpz
//
//  Created by JettDo on 3/11/19.
//  Copyright Â© 2019 JettDo.Drexel2019. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class WaterRing : NSObject {
    
    //// Cache
    
    private struct Cache {
        static let outerRing1: UIColor = UIColor(red: 0.000, green: 0.122, blue: 0.259, alpha: 1.000)
        static let innerRing1Color: UIColor = UIColor(red: 0.000, green: 0.475, blue: 1.000, alpha: 1.000)
        static let innerRing2Color: UIColor = UIColor(red: 0.000, green: 0.475, blue: 1.000, alpha: 1.000)
        static let fillColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        static let shadowTint: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        static let gradientColor: UIColor = UIColor(red: 0.000, green: 0.188, blue: 0.404, alpha: 1.000)
        static let outerRingTintColor: UIColor = WaterRing.outerRing1.withBrightness(0.2)
        static let ringGradientColor: UIColor = UIColor(red: 0.000, green: 0.475, blue: 1.000, alpha: 1.000)
        static let ringGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [WaterRing.innerRing1Color.cgColor, WaterRing.ringGradientColor.cgColor] as CFArray, locations: [0, 1])!
        static let gradient: CGGradient = CGGradient(colorsSpace: nil, colors: [WaterRing.gradientColor.cgColor, WaterRing.gradientColor.cgColor] as CFArray, locations: [0, 1])!
    }
    
    //// Colors
    
    @objc dynamic public class var outerRing1: UIColor { return Cache.outerRing1 }
    @objc dynamic public class var innerRing1Color: UIColor { return Cache.innerRing1Color }
    @objc dynamic public class var innerRing2Color: UIColor { return Cache.innerRing2Color }
    @objc dynamic public class var fillColor: UIColor { return Cache.fillColor }
    @objc dynamic public class var shadowTint: UIColor { return Cache.shadowTint }
    @objc dynamic public class var gradientColor: UIColor { return Cache.gradientColor }
    @objc dynamic public class var outerRingTintColor: UIColor { return Cache.outerRingTintColor }
    @objc dynamic public class var ringGradientColor: UIColor { return Cache.ringGradientColor }
    
    //// Gradients
    
    @objc dynamic public class var ringGradient: CGGradient { return Cache.ringGradient }
    @objc dynamic public class var gradient: CGGradient { return Cache.gradient }
    
    //// Drawing Methods
    
    @objc dynamic public class func drawAnimation(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 130, height: 130), resizing: ResizingBehavior = .aspectFit, progress: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 130, height: 130), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 130, y: resizedFrame.height / 130)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 130, resizedFrame.height / 130)
        
        
        
        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black.withAlphaComponent(0.56)
        shadow.shadowOffset = CGSize(width: 0, height: 0)
        shadow.shadowBlurRadius = 8
        
        //// Variable Declarations
        let progressRing: CGFloat = progress * 300
        
        //// Ring Group
        //// Outer Ring Drawing
        let outerRingPath = UIBezierPath()
        outerRingPath.move(to: CGPoint(x: 65, y: 50))
        outerRingPath.addCurve(to: CGPoint(x: 61.63, y: 50.38), controlPoint1: CGPoint(x: 63.84, y: 50), controlPoint2: CGPoint(x: 62.72, y: 50.13))
        outerRingPath.addCurve(to: CGPoint(x: 50, y: 65), controlPoint1: CGPoint(x: 54.97, y: 51.91), controlPoint2: CGPoint(x: 50, y: 57.87))
        outerRingPath.addCurve(to: CGPoint(x: 65, y: 80), controlPoint1: CGPoint(x: 50, y: 73.28), controlPoint2: CGPoint(x: 56.72, y: 80))
        outerRingPath.addCurve(to: CGPoint(x: 80, y: 65), controlPoint1: CGPoint(x: 73.28, y: 80), controlPoint2: CGPoint(x: 80, y: 73.28))
        outerRingPath.addCurve(to: CGPoint(x: 65, y: 50), controlPoint1: CGPoint(x: 80, y: 56.72), controlPoint2: CGPoint(x: 73.28, y: 50))
        outerRingPath.close()
        outerRingPath.move(to: CGPoint(x: 125, y: 65))
        outerRingPath.addCurve(to: CGPoint(x: 65, y: 125), controlPoint1: CGPoint(x: 125, y: 98.14), controlPoint2: CGPoint(x: 98.14, y: 125))
        outerRingPath.addCurve(to: CGPoint(x: 5, y: 65), controlPoint1: CGPoint(x: 31.86, y: 125), controlPoint2: CGPoint(x: 5, y: 98.14))
        outerRingPath.addCurve(to: CGPoint(x: 30.38, y: 15.99), controlPoint1: CGPoint(x: 5, y: 44.76), controlPoint2: CGPoint(x: 15.03, y: 26.85))
        outerRingPath.addCurve(to: CGPoint(x: 65, y: 5), controlPoint1: CGPoint(x: 40.16, y: 9.07), controlPoint2: CGPoint(x: 52.11, y: 5))
        outerRingPath.addCurve(to: CGPoint(x: 125, y: 65), controlPoint1: CGPoint(x: 98.14, y: 5), controlPoint2: CGPoint(x: 125, y: 31.86))
        outerRingPath.close()
        WaterRing.outerRing1.setFill()
        outerRingPath.fill()
        
        
        //// Inter Ring Drawing
        context.saveGState()
        context.translateBy(x: 65.5, y: 64.5)
        
        let interRingPath = UIBezierPath(ovalIn: CGRect(x: -32.5, y: -32.5, width: 65, height: 65))
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        WaterRing.gradientColor.setFill()
        interRingPath.fill()
        context.restoreGState()
        
        
        context.restoreGState()
        
        
        //// Water Drop Drawing
        let waterDropPath = UIBezierPath()
        waterDropPath.move(to: CGPoint(x: 64.98, y: 78))
        waterDropPath.addCurve(to: CGPoint(x: 75, y: 67.98), controlPoint1: CGPoint(x: 70.51, y: 78), controlPoint2: CGPoint(x: 75, y: 73.52))
        waterDropPath.addCurve(to: CGPoint(x: 64.98, y: 50.78), controlPoint1: CGPoint(x: 75, y: 64.3), controlPoint2: CGPoint(x: 71.66, y: 58.56))
        waterDropPath.addCurve(to: CGPoint(x: 54.95, y: 67.98), controlPoint1: CGPoint(x: 58.29, y: 58.56), controlPoint2: CGPoint(x: 54.95, y: 64.3))
        waterDropPath.addCurve(to: CGPoint(x: 64.98, y: 78), controlPoint1: CGPoint(x: 54.95, y: 73.52), controlPoint2: CGPoint(x: 59.44, y: 78))
        waterDropPath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        waterDropPath.usesEvenOddFillRule = true
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        waterDropPath.addClip()
        context.drawLinearGradient(WaterRing.ringGradient, start: CGPoint(x: 64.98, y: 50.78), end: CGPoint(x: 64.98, y: 78), options: [])
        context.endTransparencyLayer()
        context.restoreGState()
        
        
        
        
        
        //// Mask Group
        context.saveGState()
        context.translateBy(x: 65, y: 65)
        context.rotate(by: 90 * CGFloat.pi/180)
        
        
        
        //// Mask ring Drawing
        let maskRingPath = UIBezierPath()
        maskRingPath.move(to: CGPoint(x: -46, y: -0))
        maskRingPath.addCurve(to: CGPoint(x: -0, y: -46), controlPoint1: CGPoint(x: -46, y: -25.41), controlPoint2: CGPoint(x: -25.41, y: -46))
        maskRingPath.addCurve(to: CGPoint(x: 46, y: -0), controlPoint1: CGPoint(x: 25.41, y: -46), controlPoint2: CGPoint(x: 46, y: -25.41))
        maskRingPath.addCurve(to: CGPoint(x: 0, y: 46), controlPoint1: CGPoint(x: 46, y: 25.41), controlPoint2: CGPoint(x: 25.41, y: 46))
        maskRingPath.addCurve(to: CGPoint(x: -46, y: -0), controlPoint1: CGPoint(x: -25.41, y: 46), controlPoint2: CGPoint(x: -46, y: 25.41))
        maskRingPath.close()
        WaterRing.innerRing1Color.setStroke()
        maskRingPath.lineWidth = 18
        maskRingPath.lineCapStyle = .round
        context.saveGState()
        context.setLineDash(phase: 0, lengths: [progressRing, 300])
        maskRingPath.stroke()
        context.restoreGState()
        
        
        
        context.restoreGState()
        
        
        //// Arrow
        context.saveGState()
        context.translateBy(x: 64.5, y: 19)
        
        
        
        //// Bezier Drawing
        context.saveGState()
        context.translateBy(x: 1.5, y: -0)
        
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: -5, y: 0))
        bezierPath.addLine(to: CGPoint(x: 0, y: 0))
        UIColor.white.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.lineCapStyle = .round
        bezierPath.stroke()
        
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        context.saveGState()
        context.translateBy(x: 3.5, y: 0)
        context.rotate(by: 45 * CGFloat.pi/180)
        
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: -3, y: -0))
        bezier2Path.addLine(to: CGPoint(x: 0, y: 0))
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.lineCapStyle = .round
        bezier2Path.stroke()
        
        context.restoreGState()
        
        
        //// Bezier 3 Drawing
        context.saveGState()
        context.translateBy(x: 3.5, y: 0)
        context.rotate(by: -45 * CGFloat.pi/180)
        
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: -3, y: -0))
        bezier3Path.addLine(to: CGPoint(x: 0, y: 0))
        UIColor.white.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.lineCapStyle = .round
        bezier3Path.stroke()
        
        context.restoreGState()
        
        
        //// Bezier 4 Drawing
        context.saveGState()
        context.translateBy(x: 1.5, y: 0)
        context.rotate(by: 45 * CGFloat.pi/180)
        
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: -3, y: -0))
        bezier4Path.addLine(to: CGPoint(x: 0, y: 0))
        UIColor.white.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.lineCapStyle = .round
        bezier4Path.stroke()
        
        context.restoreGState()
        
        
        //// Bezier 5 Drawing
        context.saveGState()
        context.translateBy(x: 1.5, y: 0)
        context.rotate(by: -45 * CGFloat.pi/180)
        
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: -3, y: -0))
        bezier5Path.addLine(to: CGPoint(x: 0, y: 0))
        UIColor.white.setStroke()
        bezier5Path.lineWidth = 1
        bezier5Path.lineCapStyle = .round
        bezier5Path.stroke()
        
        context.restoreGState()
        
        
        
        context.restoreGState()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawProgressAnimationDark(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 130, height: 130), resizing: ResizingBehavior = .aspectFit, progress: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 130, height: 130), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 130, y: resizedFrame.height / 130)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 130, resizedFrame.height / 130)
        
        
        
        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black.withAlphaComponent(0.56)
        shadow.shadowOffset = CGSize(width: 0, height: 0)
        shadow.shadowBlurRadius = 8
        
        //// Ring Group
        context.saveGState()
        context.translateBy(x: 65, y: 65)
        
        
        
        //// Outer Ring Drawing
        let outerRingPath = UIBezierPath()
        outerRingPath.move(to: CGPoint(x: 0, y: -15))
        outerRingPath.addCurve(to: CGPoint(x: -3.37, y: -14.62), controlPoint1: CGPoint(x: -1.16, y: -15), controlPoint2: CGPoint(x: -2.28, y: -14.87))
        outerRingPath.addCurve(to: CGPoint(x: -15, y: 0), controlPoint1: CGPoint(x: -10.03, y: -13.09), controlPoint2: CGPoint(x: -15, y: -7.13))
        outerRingPath.addCurve(to: CGPoint(x: 0, y: 15), controlPoint1: CGPoint(x: -15, y: 8.28), controlPoint2: CGPoint(x: -8.28, y: 15))
        outerRingPath.addCurve(to: CGPoint(x: 15, y: 0), controlPoint1: CGPoint(x: 8.28, y: 15), controlPoint2: CGPoint(x: 15, y: 8.28))
        outerRingPath.addCurve(to: CGPoint(x: 0, y: -15), controlPoint1: CGPoint(x: 15, y: -8.28), controlPoint2: CGPoint(x: 8.28, y: -15))
        outerRingPath.close()
        outerRingPath.move(to: CGPoint(x: 60, y: 0))
        outerRingPath.addCurve(to: CGPoint(x: -0, y: 60), controlPoint1: CGPoint(x: 60, y: 33.14), controlPoint2: CGPoint(x: 33.14, y: 60))
        outerRingPath.addCurve(to: CGPoint(x: -60, y: 0), controlPoint1: CGPoint(x: -33.14, y: 60), controlPoint2: CGPoint(x: -60, y: 33.14))
        outerRingPath.addCurve(to: CGPoint(x: -34.62, y: -49.01), controlPoint1: CGPoint(x: -60, y: -20.24), controlPoint2: CGPoint(x: -49.97, y: -38.15))
        outerRingPath.addCurve(to: CGPoint(x: 0, y: -60), controlPoint1: CGPoint(x: -24.84, y: -55.93), controlPoint2: CGPoint(x: -12.89, y: -60))
        outerRingPath.addCurve(to: CGPoint(x: 60, y: 0), controlPoint1: CGPoint(x: 33.14, y: -60), controlPoint2: CGPoint(x: 60, y: -33.14))
        outerRingPath.close()
        WaterRing.outerRingTintColor.setFill()
        outerRingPath.fill()
        
        
        //// Inter Ring Drawing
        context.saveGState()
        context.translateBy(x: 0.5, y: -0.5)
        
        let interRingPath = UIBezierPath(ovalIn: CGRect(x: -32.5, y: -32.5, width: 65, height: 65))
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        WaterRing.outerRing1.setFill()
        interRingPath.fill()
        context.restoreGState()
        
        
        context.restoreGState()
        
        
        //// Water Drop Drawing
        let waterDropPath = UIBezierPath()
        waterDropPath.move(to: CGPoint(x: -0.02, y: 13))
        waterDropPath.addCurve(to: CGPoint(x: 10, y: 2.98), controlPoint1: CGPoint(x: 5.51, y: 13), controlPoint2: CGPoint(x: 10, y: 8.52))
        waterDropPath.addCurve(to: CGPoint(x: -0.02, y: -14.22), controlPoint1: CGPoint(x: 10, y: -0.7), controlPoint2: CGPoint(x: 6.66, y: -6.44))
        waterDropPath.addCurve(to: CGPoint(x: -10.05, y: 2.98), controlPoint1: CGPoint(x: -6.71, y: -6.44), controlPoint2: CGPoint(x: -10.05, y: -0.7))
        waterDropPath.addCurve(to: CGPoint(x: -0.02, y: 13), controlPoint1: CGPoint(x: -10.05, y: 8.52), controlPoint2: CGPoint(x: -5.56, y: 13))
        waterDropPath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        waterDropPath.usesEvenOddFillRule = true
        WaterRing.innerRing2Color.setFill()
        waterDropPath.fill()
        context.restoreGState()
        
        
        
        
        context.restoreGState()
        
        
        //// Simple Group
        context.saveGState()
        context.setBlendMode(.sourceAtop)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        
        
        //// Symbol Drawing
        let symbolRect = CGRect(x: 0, y: 0, width: 130, height: 130)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        
        WaterRing.drawAnimation(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, progress: progress)
        context.restoreGState()
        
        
        context.endTransparencyLayer()
        context.restoreGState()
        
        context.restoreGState()
        
    }
    
    
    
    
    @objc(WaterRingResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.
        
        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }
            
            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)
            
            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }
            
            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func withHue(_ newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func withSaturation(_ newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func withBrightness(_ newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func withAlpha(_ newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, brightness: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func highlight(withLevel highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func shadow(withLevel shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
}
